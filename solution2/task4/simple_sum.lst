     1                                  ; Задача №2.2. Сумма двух 16-битных чисел
     2                                  
     3                                  ; (*) Ошибки обработчиков ошибок не обрабатываются
     4                                  ; (*) r13 зарезервирован под код выполнения программы:
     5                                  ;   r13 = 0 - Успешное выполнение программы
     6                                  ;   r13 > 0 - Количество записанных байт не соотвествует ожидаемому значению
     7                                  ;   r13 < 0 - Системный вызов провалился
     8                                  
     9                                  %define MAX_INPUT_STR_SIZE 6                            ; максимальная длина строки ввода
    10                                  %define MAX_OUTPUT_STR_SIZE 100                         ; максимальная длина буфера вывода
    11                                  
    12                                  %define READ 0                                          ; номер системного вызова read
    13                                  %define WRITE 1                                         ; номер системного вызова write
    14                                  %define EXIT 60                                         ; номер системного вызова exit
    15                                  
    16                                  %define STDIN 0                                         ; дескриптор стандартного ввода
    17                                  %define STDOUT 1                                        ; дескриптор стандартного вывода
    18                                  %define STDERR 2                                        ; дескриптор стандартного потока ошибок
    19                                  
    20                                  %define NULL_CHAR 0                                     ; нуль-терминатор
    21                                  %define NEWLINE 0x0A                                    ; символ перевода строки '\n'
    22                                  
    23                                  global _start                                           ; точка входа программы
    24                                  
    25                                  section .bss                                            ; секция для глобальных неинициализированных переменных
    26 00000000 ????????????                x1_str resb MAX_INPUT_STR_SIZE                      ; буфер для первой введённой строки
    27 00000006 ????????????                x2_str resb MAX_INPUT_STR_SIZE                      ; буфер для второй введённой строки
    28 0000000C ????                        x1 resw 1                                           ; переменная для хранения первого числа (16 бит)
    29 0000000E ????                        x2 resw 1                                           ; переменная для хранения второго числа (16 бит)
    30 00000010 <res 64h>                   sum_str resb MAX_OUTPUT_STR_SIZE                    ; буфер для строки с суммой
    31                                  
    32                                  section .data                                           ; секция для константных данных
    33                                      ; Подсказки в консоли
    34 00000000 456E7465722031206E-         prompt1 db "Enter 1 number: ", NULL_CHAR            ; подсказка для ввода первого числа
    34 00000009 756D6265723A2000   
    35                                      len_prompt1 equ $-prompt1                           ; длина подсказки 1
    36                                  
    37 00000011 456E7465722032206E-         prompt2 db "Enter 2 number: ", NULL_CHAR            ; подсказка для ввода второго числа
    37 0000001A 756D6265723A2000   
    38                                      len_prompt2 equ $-prompt2                           ; длина подсказки 2
    39                                  
    40 00000022 416E737765723A2000          msg_result db "Answer: ", NULL_CHAR                 ; сообщение перед выводом результата
    41                                      len_msg_result equ $-msg_result                     ; длина сообщения
    42                                  
    43 0000002B 0A                          newline db 0x0A                                     ; символ новой строки
    44                                  
    45                                      ; Сообщения об ошибках
    46 0000002C 4572726F723A207772-         write_failed_msg db "Error: write() failed", NEWLINE, NULL_CHAR
    46 00000035 697465282920666169-
    46 0000003E 6C65640A00         
    47                                      write_failed_msg_len equ $-write_failed_msg
    48                                  
    49 00000043 4572726F723A207772-         write_byte_number_mismatch_msg db "Error: write() write wrong number of bytes", NEWLINE, NULL_CHAR
    49 0000004C 697465282920777269-
    49 00000055 74652077726F6E6720-
    49 0000005E 6E756D626572206F66-
    49 00000067 2062797465730A00   
    50                                      write_byte_number_mismatch_msg_len equ $-write_byte_number_mismatch_msg
    51                                  
    52 0000006F 4572726F723A207265-         read_failed_msg db "Error: read() failed", NEWLINE, NULL_CHAR
    52 00000078 61642829206661696C-
    52 00000081 65640A00           
    53                                      read_failed_msg_len equ $-read_failed_msg
    54                                  
    55                                  section .text                                           ; секция кода
    56                                  
    57                                  _start:                                                 ; точка входа программы
    58 00000000 4D31ED                      xor r13, r13                                        ; устанавливаем код завершения r13 = 0 (успех)
    59                                  
    60                                      ; ---- Промпт 1 ----
    61 00000003 B801000000                  mov rax, WRITE                                      ; системный вызов write
    62 00000008 BF01000000                  mov rdi, STDOUT                                     ; дескриптор stdout
    63 0000000D 488D35(00000000)            lea rsi, [rel prompt1]                              ; адрес буфера с подсказкой
    64 00000014 BA11000000                  mov rdx, len_prompt1                                ; длина подсказки
    65 00000019 0F05                        syscall                                             ; выполнить системный вызов
    66                                  
    67 0000001B 4885C0                      test rax, rax                                       ; проверка возвращенного значения rax (кол-во записанных байт)
    68 0000001E 0F881A020000                js write_failed_handler                             ; если rax < 0 (ошибка), прыжок к обработчику ошибки записи
    69                                  
    70 00000024 4839D0                      cmp rax, rdx                                        ; проверяем, совпадает ли количество записанных байт с ожидаемым
    71 00000027 0F852E020000                jne write_byte_number_mismatch_handler              ; если нет, прыжок к обработчику несоответствия байт
    72                                  
    73                                      ; ---- Считываем первое число ----
    74 0000002D 488D3D(00000000)            lea rdi, [rel x1_str]                               ; адрес буфера ввода строки
    75 00000034 488D35(0C000000)            lea rsi, [rel x1]                                   ; адрес переменной для хранения числа
    76 0000003B E8CA000000                  call read_num                                       ; вызов функции чтения и конвертации числа
    77                                  
    78                                      ; ---- Промпт 2 ----
    79 00000040 B801000000                  mov rax, WRITE
    80 00000045 BF01000000                  mov rdi, STDOUT
    81 0000004A 488D35(11000000)            lea rsi, [rel prompt2]
    82 00000051 BA11000000                  mov rdx, len_prompt2
    83 00000056 0F05                        syscall
    84                                  
    85 00000058 4885C0                      test rax, rax                                       ; проверка возвращенного значения rax (кол-во записанных байт)
    86 0000005B 0F88DD010000                js write_failed_handler                             ; если rax < 0 (ошибка), прыжок к обработчику ошибки записи
    87                                  
    88 00000061 4839D0                      cmp rax, rdx                                        ; проверяем, совпадает ли количество записанных байт с ожидаемым
    89 00000064 0F85F1010000                jne write_byte_number_mismatch_handler              ; если нет, прыжок к обработчику несоответствия байт
    90                                  
    91                                      ; ---- Считываем второе число ----
    92 0000006A 488D3D(06000000)            lea rdi, [rel x2_str]                               ; адрес буфера ввода строки
    93 00000071 488D35(0E000000)            lea rsi, [rel x2]                                   ; адрес переменной для хранения числа
    94 00000078 E88D000000                  call read_num
    95                                  
    96                                      ; ---- Складываем числа ----
    97 0000007D 480FBF05(0C000000)          movsx rax, word [rel x1]                            ; расширяем первое число до 64 бит с сохранением знака
    98 00000085 480FBF1D(0E000000)          movsx rbx, word [rel x2]                            ; расширяем второе число до 64 бит с сохранением знака
    99 0000008D 4801D8                      add rax, rbx                                        ; складываем числа
   100 00000090 668905(0C000000)            mov [rel x1], ax                                    ; сохраняем результат в x1 (16 бит)
   101                                  
   102                                      ; ---- Вывести подсказку к результату ----
   103 00000097 B801000000                  mov rax, WRITE
   104 0000009C BF01000000                  mov rdi, STDOUT
   105 000000A1 488D35(22000000)            lea rsi, [rel msg_result]
   106 000000A8 BA09000000                  mov rdx, len_msg_result
   107 000000AD 0F05                        syscall
   108                                  
   109 000000AF 4885C0                      test rax, rax                                       ; проверка возвращенного значения rax (кол-во записанных байт)
   110 000000B2 0F8886010000                js write_failed_handler                             ; если rax < 0 (ошибка), прыжок к обработчику ошибки записи
   111                                  
   112 000000B8 4839D0                      cmp rax, rdx                                        ; проверяем, совпадает ли количество записанных байт с ожидаемым
   113 000000BB 0F859A010000                jne write_byte_number_mismatch_handler              ; если нет, прыжок к обработчику несоответствия байт
   114                                  
   115                                      ; ---- Вывести сумму ----
   116 000000C1 480FBF05(0C000000)          movsx rax, word [rel x1]                            ; расширяем сумму до 64 бит
   117 000000C9 488D35(10000000)            lea rsi, [rel sum_str]                              ; адрес буфера вывода
   118 000000D0 BA64000000                  mov rdx, MAX_OUTPUT_STR_SIZE
   119 000000D5 E8BD000000                  call print_num                                      ; вызов функции печати числа
   120                                  
   121                                      ; ---- Добавить новую строку ----
   122 000000DA B801000000                  mov rax, WRITE
   123 000000DF BF01000000                  mov rdi, STDOUT
   124 000000E4 488D35(2B000000)            lea rsi, [rel newline]
   125 000000EB BA01000000                  mov rdx, 1
   126 000000F0 0F05                        syscall
   127                                  
   128 000000F2 4885C0                      test rax, rax                                       ; проверка возвращенного значения rax (кол-во записанных байт)
   129 000000F5 0F8843010000                js write_failed_handler                             ; если rax < 0 (ошибка), прыжок к обработчику ошибки записи
   130                                  
   131 000000FB 4883F801                    cmp rax, 1                                          ; проверяем, совпадает ли количество записанных байт с ожидаемым
   132 000000FF 0F8556010000                jne write_byte_number_mismatch_handler              ; если нет, прыжок к обработчику несоответствия байт
   133                                  
   134                                      ; ---- Выход ----
   135 00000105 E98B010000                  jmp exit                                            ; завершение программы
   136                                  
   137                                  ; --------------------------------------------------
   138                                  ; Функция read_num: чтение строки и конвертация в число
   139                                  ; rdi = адрес введенной строки
   140                                  ; rsi = адрес переменной для хранения числа
   141                                  ; --------------------------------------------------
   142                                  read_num:
   143 0000010A 55                          push rbp                                            ; сохраняем rbp
   144 0000010B 4889E5                      mov rbp, rsp                                        ; устанавливаем новый базовый указатель
   145                                  
   146                                      ; сохраняем callee-saved регистры
   147 0000010E 4154                        push r12
   148 00000110 53                          push rbx
   149                                  
   150 00000111 4889FB                      mov rbx, rdi                                        ; rbx = адрес буфера ввода
   151 00000114 4989F4                      mov r12, rsi                                        ; r12 = адрес переменной для хранения числа
   152                                  
   153 00000117 B800000000                  mov rax, READ                                       ; передаем номер системного вызова
   154 0000011C BF00000000                  mov rdi, STDIN                                      ; передаём дескриптор входного потока
   155 00000121 4889DE                      mov rsi, rbx                                        ; адрес буфера для сохранения введенной строки
   156 00000124 BA06000000                  mov rdx, MAX_INPUT_STR_SIZE                         ; количество байтов для чтения
   157 00000129 0F05                        syscall                                             ; выполнить системный вызов read
   158                                  
   159                                  
   160 0000012B 4885C0                      test rax, rax
   161 0000012E 0F8844010000                js read_failed_handler                              ; если ошибка чтения
   162                                  
   163 00000134 4889C1                      mov rcx, rax                                        ; сохраняем длину строки
   164 00000137 48FFC9                      dec rcx                                             ; делаем указателем на последний индекс
   165 0000013A 8A040B                      mov al, [rbx + rcx]                                 ; сохраняем последний символ в регистр
   166 0000013D 3C0A                        cmp al, NEWLINE                                     ; проверяем на '\n'
   167 0000013F 7504                        jne .no_newline
   168 00000141 C6040B00                    mov byte [rbx + rcx], NULL_CHAR                     ; заменяем '\n' на нуль-терминатор
   169                                  
   170                                  .no_newline:
   171 00000145 4889DF                      mov rdi, rbx
   172 00000148 E80E000000                  call str_to_num                                     ; конвертация строки в число
   173 0000014D 480FBFC0                    movsx rax, ax
   174 00000151 6641890424                  mov [r12], ax                                       ; сохраняем результат по адресу в указателе
   175                                  
   176 00000156 5B                          pop rbx
   177 00000157 415C                        pop r12
   178 00000159 5D                          pop rbp
   179 0000015A C3                          ret
   180                                  
   181                                  ; --------------------------------------------------
   182                                  ; Функция str_to_num: конвертация строки в знаковое число
   183                                  ; rdi = адрес строки
   184                                  ; --------------------------------------------------
   185                                  str_to_num:
   186 0000015B 55                          push rbp                                            ; сохраняем rbp
   187 0000015C 4889E5                      mov rbp, rsp                                        ; устанавливаем новый базовый указатель
   188                                  
   189 0000015F 4831C0                      xor rax, rax                                        ; обнуляем rax
   190 00000162 4831D2                      xor rdx, rdx                                        ; обнуляем rdx
   191 00000165 4889FE                      mov rsi, rdi                                        ; сохраняем адрес строки
   192                                  
   193 00000168 8A1E                        mov bl, [rsi]                                       ; сохраняем символ по нулевому индексу
   194 0000016A 80FB2D                      cmp bl, '-'                                         ; проверяем на минус
   195 0000016D 7505                        jne .parse_loop                                     ; если минуса нету, то сразу переходим к преобразованию
   196 0000016F B201                        mov dl, 1                                           ; устанавливаем флаг "отрицательное число" в 1
   197 00000171 48FFC6                      inc rsi                                             ; пропускаем знак минуса
   198                                  .parse_loop:
   199 00000174 8A1E                        mov bl, [rsi]                                       ; сохраняем текущий символ из адреса в указателе
   200 00000176 80FB00                      cmp bl, NULL_CHAR                                   ; итерируемся до null-терминатора
   201 00000179 7413                        je .done_parse                                      ; если дошли до '\0', то цикл заканчивается
   202 0000017B 80EB30                      sub bl, '0'                                         ; переводим символ цифры в число
   203 0000017E 486BC00A                    imul rax, rax, 10                                   ; знаковое умножение: arg1 - регистр результата, arg2 - регистр множителя, arg3 - константа
   204 00000182 480FB6DB                    movzx rbx, bl                                       ; movzx - move zero extended, расширяем нулями 8-битный регистр до 64-битного
   205 00000186 4801D8                      add rax, rbx                                        ; прибавляем цифру в конец числа                 
   206 00000189 48FFC6                      inc rsi                                             ; увеличиваем индекс
   207 0000018C EBE6                        jmp .parse_loop
   208                                  .done_parse:
   209 0000018E 84D2                        test dl, dl                                         ; проверка флага "отрицательного числа"
   210 00000190 7403                        jz .finish_return
   211 00000192 48F7D8                      neg rax                                             ; инвертируем знак числа
   212                                  .finish_return:
   213 00000195 5D                          pop rbp
   214 00000196 C3                          ret
   215                                  
   216                                  ; --------------------------------------------------
   217                                  ; Функция read_num: вывод числа
   218                                  ; rax = число
   219                                  ; rsi = адрес буфера вывода
   220                                  ; rdi = количество байт для вывода
   221                                  ; --------------------------------------------------
   222                                  print_num:
   223 00000197 55                          push rbp
   224 00000198 4889E5                      mov rbp, rsp
   225                                  
   226 0000019B 4889FA                      mov rdx, rdi                                        ; передаем количество байт для вывода в num_to_str
   227 0000019E 4889C7                      mov rdi, rax                                        ; передаем число в num_to_str
   228                                      ; также передаём rsi и rdx
   229 000001A1 E82A000000                  call num_to_str                                     ; конвертация числа в строку
   230                                  
   231 000001A6 4889C7                      mov rdi, rax                                        ; указатель на первый байт новой строки
   232 000001A9 E87C000000                  call strlen                                         ; вычисление длины строки
   233 000001AE 4889C2                      mov rdx, rax                                        ; длина для write
   234 000001B1 4889FE                      mov rsi, rdi                                        ; указатель на строку
   235 000001B4 B801000000                  mov rax, WRITE
   236 000001B9 BF01000000                  mov rdi, STDOUT
   237 000001BE 0F05                        syscall
   238                                  
   239 000001C0 4885C0                      test rax, rax                                       ; проверка возвращенного значения rax (кол-во записанных байт)
   240 000001C3 7879                        js write_failed_handler                             ; если rax < 0 (ошибка), прыжок к обработчику ошибки записи
   241                                  
   242 000001C5 4839D0                      cmp rax, rdx                                        ; проверяем, совпадает ли количество записанных байт с ожидаемым
   243 000001C8 0F858D000000                jne write_byte_number_mismatch_handler              ; если нет, прыжок к обработчику несоответствия байт
   244                                  
   245 000001CE 5D                          pop rbp
   246 000001CF C3                          ret
   247                                  
   248                                  ; --------------------------------------------------
   249                                  ; Функция num_to_str: конвертация числа в строку
   250                                  ; rdi = число
   251                                  ; rsi = адрес строки результата
   252                                  ; rdx = размер строки результата
   253                                  ; Возвращает в rax: указатель на первый байт новой строки
   254                                  ; --------------------------------------------------
   255                                  num_to_str:
   256 000001D0 55                          push rbp
   257 000001D1 4889E5                      mov rbp, rsp
   258                                  
   259 000001D4 4889F8                      mov rax, rdi                                        ; сохраняем число в rax для дальнейшего div
   260 000001D7 4989D2                      mov r10, rdx                                        ; сохраняем параметр
   261                                  
   262 000001DA 4E8D5C16FF                  lea r11, [rsi + r10 - 1]                            ; сохраняем адрес последнего индекса буфера
   263 000001DF 41C60300                    mov byte [r11], NULL_CHAR                           ; ставим в конец строки нуль-терминатор
   264                                  
   265 000001E3 4D31C9                      xor r9, r9                                          ; флаг отрицательного числа
   266 000001E6 4885C0                      test rax, rax                                       ; проверяем число на отрицательность
   267 000001E9 7906                        jns .parse_start
   268                                  
   269 000001EB 41B101                      mov r9b, 1                                          ; помещаем 1 в 8-битовый r9 регистр, остальные 56 бит не изменяются
   270 000001EE 48F7D8                      neg rax                                             ; конвертируем дополнительный код к обычному
   271                                  .parse_start:
   272 000001F1 4883F800                    cmp rax, 0                                          ; проверяем на нулевое число                 
   273 000001F5 7509                        jne .parse_loop
   274 000001F7 49FFCB                      dec r11                                             ; передвигаем указатель на предпоследний индекс
   275 000001FA 41C60330                    mov byte [r11], '0'                                 ; помещаем туда символ нуля
   276 000001FE EB19                        jmp .check_sign                                     ; сразу переходим к следующему блоку обработки
   277                                  .parse_loop:
   278 00000200 4831D2                      xor rdx, rdx                                        ; обнуляем rdx - верхняя половина rdx:rax перед делением и остаток после деления
   279 00000203 B90A000000                  mov rcx, 10                                         ; передаем 10 в регистр для div
   280 00000208 48F7F1                      div rcx                                             ; беззнаковое деление объединненного rdx:rax на другой регистр, частное записывается в rax
   281 0000020B 80C230                      add dl, '0'                                         ; прибавляем к остатку (цифре) код символа '0'
   282 0000020E 49FFCB                      dec r11                                             ; передвигаем указатель влево
   283 00000211 418813                      mov [r11], dl                                       ; сохраняем символ цифры по адресу в указателе
   284 00000214 4885C0                      test rax, rax                                       ; проверяем частное на ноль
   285 00000217 75E7                        jnz .parse_loop
   286                                  .check_sign:
   287 00000219 4584C9                      test r9b, r9b                                       ; проверяем флаг отрицательного числа
   288 0000021C 7407                        jz .finish_return                                   ; если не установлен, выходим из функции
   289 0000021E 49FFCB                      dec r11                                             ; передвигаем указатель влево
   290 00000221 41C6032D                    mov byte [r11], '-'                                 ; сохраняем символ минуса по адресу в указателе
   291                                  .finish_return:
   292 00000225 4C89D8                      mov rax, r11                                        ; возвращаем указатель на начало строки
   293 00000228 5D                          pop rbp
   294 00000229 C3                          ret
   295                                  
   296                                  ; --------------------------------------------------
   297                                  ; Функция strlen: вычисление длины строки
   298                                  ; rdi = адрес строки
   299                                  ; Возвращает в rax: длину строки
   300                                  ; --------------------------------------------------
   301                                  strlen:
   302 0000022A 55                          push rbp
   303 0000022B 4889E5                      mov rbp, rsp
   304                                  
   305 0000022E 4831C0                      xor rax, rax
   306                                  .next_chr:
   307 00000231 803C0700                    cmp byte [rdi + rax], NULL_CHAR
   308 00000235 7405                        je .finish_return
   309 00000237 48FFC0                      inc rax
   310 0000023A EBF5                        jmp .next_chr
   311                                  .finish_return:
   312 0000023C 5D                          pop rbp
   313 0000023D C3                          ret
   314                                  
   315                                  ; ----------------------------
   316                                  ; Обработчики ошибок
   317                                  ; ----------------------------
   318                                  write_failed_handler:                                   ; метка обработчика ошибки write()
   319 0000023E 4989C5                      mov r13, rax                                        ; сохраняем код ошибки
   320                                  
   321 00000241 B801000000                  mov rax, WRITE                                      ; системный вызов write
   322 00000246 BF02000000                  mov rdi, STDERR                                     ; дескриптор потока ошибок
   323 0000024B 488D35(2C000000)            lea rsi, [rel write_failed_msg]                     ; адрес сообщения
   324 00000252 BA17000000                  mov rdx, write_failed_msg_len                       ; длина сообщения
   325 00000257 0F05                        syscall                                             ; выполняем системный вызов write
   326                                  
   327 00000259 EB3A                        jmp exit                                            ; завершение программы
   328                                  
   329                                  write_byte_number_mismatch_handler:                     ; метка обработчика несоответствия байт
   330 0000025B 4989C5                      mov r13, rax                                        ; сохраняем код ошибки
   331                                  
   332 0000025E B801000000                  mov rax, WRITE                                      ; системный вызов write
   333 00000263 BF02000000                  mov rdi, STDERR                                     ; дескриптор потока ошибок
   334 00000268 488D35(43000000)            lea rsi, [rel write_byte_number_mismatch_msg]       ; адрес сообщения
   335 0000026F BA2C000000                  mov rdx, write_byte_number_mismatch_msg_len         ; длина сообщения
   336 00000274 0F05                        syscall                                             ; выполняем системный вызов write
   337                                  
   338 00000276 EB1D                        jmp exit                                            ; завершение программы
   339                                  
   340                                  read_failed_handler:                                    ; метка обработчика ошибки read()
   341 00000278 4989C5                      mov r13, rax                                        ; сохраняем код ошибки
   342                                  
   343 0000027B B801000000                  mov rax, WRITE                                      ; системный вызов write
   344 00000280 BF02000000                  mov rdi, STDERR                                     ; дескриптор потока ошибок
   345 00000285 488D35(6F000000)            lea rsi, [rel read_failed_msg]                      ; адрес сообщения
   346 0000028C BA16000000                  mov rdx, read_failed_msg_len                        ; длина сообщения
   347 00000291 0F05                        syscall                                             ; выполняем системный вызов write
   348                                  
   349 00000293 EB00                        jmp exit                                            ; завершение программы
   350                                  
   351                                  exit:                                                   ; завершение программы
   352 00000295 4C89EF                      mov rdi, r13                                        ; код завершения программы
   353 00000298 B83C000000                  mov rax, EXIT
   354 0000029D 0F05                        syscall
